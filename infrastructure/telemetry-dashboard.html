<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build Telemetry Live</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #252542;
            --accent: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4466;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --border: #3a3a5a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at top, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(255, 68, 102, 0.05) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 24px;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 32px;
        }
        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent), #ff6b9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        .header .subtitle {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Live indicator */
        .live-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--success);
            border-radius: 20px;
            padding: 6px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--success);
            margin-bottom: 16px;
        }
        .live-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .live-badge.stopped { border-color: var(--danger); color: var(--danger); background: rgba(255, 68, 102, 0.1); }
        .live-badge.stopped::before { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 24px;
        }
        .input-group {
            display: flex;
            align-items: center;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 4px;
        }
        .input-group input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 10px 14px;
            font-size: 14px;
            outline: none;
            width: 200px;
        }
        .input-group input::placeholder { color: var(--text-secondary); }
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent), #0099cc);
            color: var(--bg-primary);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px var(--accent-glow); }
        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover { border-color: var(--accent); }

        /* Cards Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }
        .grid-full { grid-column: 1 / -1; }

        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }
        .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        .card-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--accent), #0099cc);
            border-radius: 10px;
            font-size: 20px;
        }
        .card-title {
            font-size: 16px;
            font-weight: 600;
        }

        /* Metrics */
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        .metric-row:last-child { border-bottom: none; }
        .metric-label { color: var(--text-secondary); font-size: 14px; }
        .metric-value {
            font-size: 18px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        .metric-value.success { color: var(--success); }
        .metric-value.warning { color: var(--warning); }
        .metric-value.danger { color: var(--danger); }

        /* Progress Steps */
        .steps-list { display: flex; flex-direction: column; gap: 8px; }
        .step-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 10px;
            transition: background 0.2s;
        }
        .step-item:hover { background: rgba(0, 212, 255, 0.1); }
        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .step-icon.completed { background: var(--success); color: var(--bg-primary); }
        .step-icon.running { background: var(--warning); color: var(--bg-primary); animation: pulse 1s infinite; }
        .step-icon.pending { background: var(--border); color: var(--text-secondary); }
        .step-icon.failed { background: var(--danger); color: var(--text-primary); }
        .step-icon.skipped { background: var(--text-secondary); color: var(--bg-primary); opacity: 0.6; }
        .step-item.active { background: rgba(255, 193, 7, 0.15); border-radius: 8px; margin: 2px -8px; padding: 10px 16px; }
        .step-name { flex: 1; font-size: 14px; }
        .step-duration { color: var(--text-secondary); font-size: 12px; font-variant-numeric: tabular-nums; }

        /* Build Phases */
        .build-phases { display: flex; flex-direction: column; gap: 12px; }
        .phase {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border-left: 4px solid var(--border);
            transition: all 0.3s ease;
        }
        .phase.active {
            background: rgba(255, 193, 7, 0.15);
            border-left-color: var(--warning);
        }
        .phase.completed {
            border-left-color: var(--success);
        }
        .phase-icon { font-size: 24px; }
        .phase-info { flex: 1; }
        .phase-name { font-weight: 600; font-size: 14px; }
        .phase-desc { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        .phase-status {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .phase-status.pending { background: var(--bg-primary); color: var(--text-secondary); }
        .phase-status.running { background: var(--warning); color: var(--bg-primary); animation: pulse 1s infinite; }
        .phase-status.completed { background: var(--success); color: var(--bg-primary); }
        .phase-status.failed { background: var(--danger); color: var(--text-primary); }

        /* Live Logs */
        .live-logs {
            background: #0d1117;
            border-radius: 8px;
            padding: 16px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            max-height: 300px;
            overflow-y: auto;
            color: #c9d1d9;
        }
        .live-logs::-webkit-scrollbar { width: 8px; }
        .live-logs::-webkit-scrollbar-track { background: #161b22; }
        .live-logs::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        .log-line { padding: 2px 0; white-space: pre-wrap; word-break: break-all; }
        .log-line:hover { background: rgba(255,255,255,0.05); }
        .log-placeholder { color: var(--text-secondary); font-style: italic; }
        .log-count { font-size: 12px; color: var(--text-secondary); padding: 4px 8px; background: var(--bg-secondary); border-radius: 8px; }
        .log-line.packer { color: #58a6ff; }
        .log-line.qemu { color: #a371f7; }
        .log-line.docker { color: #3fb950; }
        .log-line.error { color: #f85149; }

        /* Overall Progress Bar */
        .progress-container {
            margin: 20px 0;
            padding: 16px 20px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 14px;
        }
        .progress-bar-bg {
            height: 20px;
            background: var(--bg-secondary);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ff88);
            border-radius: 10px;
            transition: width 0.5s ease;
            position: relative;
        }
        .progress-bar-fill.animated::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Live Timer */
        .live-timer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
            padding: 16px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .live-timer .label { font-size: 12px; color: var(--text-secondary); margin-bottom: 4px; }

        /* Chart Container */
        .chart-container { position: relative; height: 280px; }

        /* Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .data-table th, .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .data-table th {
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        .data-table tr:hover { background: rgba(0, 212, 255, 0.05); }
        .data-table .highlight { color: var(--accent); font-weight: 600; }

        /* Status classes */
        .metric-value.highlight { color: var(--accent); }
        .metric-value.in_progress { color: var(--warning); }
        .metric-value.completed { color: var(--success); }
        .metric-value.success { color: var(--success); }
        .metric-value.failure { color: var(--danger); }
        .metric-value.queued { color: var(--text-secondary); }

        /* Bottleneck Alert */
        .alert {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 12px;
        }
        .alert-danger { background: rgba(255, 68, 102, 0.1); border: 1px solid var(--danger); }
        .alert-warning { background: rgba(255, 170, 0, 0.1); border: 1px solid var(--warning); }
        .alert-icon { font-size: 20px; }
        .alert-danger .alert-icon { color: var(--danger); }
        .alert-warning .alert-icon { color: var(--warning); }
        .alert-title { font-weight: 600; margin-bottom: 4px; }
        .alert-text { color: var(--text-secondary); font-size: 13px; }

        /* Live Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }
        .metric-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border);
        }
        .metric-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-card-value {
            font-size: 28px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            margin-bottom: 8px;
        }
        .metric-card-value.cpu { color: #ff6b6b; }
        .metric-card-value.mem { color: #4ecdc4; }
        .metric-card-value.disk { color: #ffe66d; }
        .metric-card-value.net { color: #a29bfe; }
        .metric-bar {
            height: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        .metric-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .metric-bar-fill.cpu { background: linear-gradient(90deg, #ff6b6b, #ee5a5a); }
        .metric-bar-fill.mem { background: linear-gradient(90deg, #4ecdc4, #44a3a0); }
        .metric-bar-fill.disk { background: linear-gradient(90deg, #ffe66d, #ffd93d); }
        .metric-bar-fill.net { background: linear-gradient(90deg, #a29bfe, #6c5ce7); }
        .metric-bar-fill.warning { background: linear-gradient(90deg, var(--warning), #ff8800); }
        .metric-bar-fill.danger { background: linear-gradient(90deg, var(--danger), #ff2244); }
        .metric-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .metric-detail {
            display: flex;
            justify-content: space-between;
        }
        .metric-detail-value {
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }
        .metric-no-data {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* JSON Input */
        #json-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        #json-modal.active { display: flex; }
        .modal-content {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 600px;
        }
        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 16px;
        }

        /* Hidden by default */
        #dashboard { display: none; }
        #dashboard.active { display: block; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Build Telemetry Dashboard</h1>
        <p class="subtitle">Real-time monitoring for CI/CD pipeline</p>
    </div>

    <div style="text-align: center;">
        <span id="live-badge" class="live-badge stopped">READY</span>
        <div id="run-info" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
    </div>

    <div class="controls">
        <input type="hidden" id="run-id">
        <button class="btn btn-primary" onclick="manualRefresh()">
            <span>üîÑ</span> Refresh
        </button>
        <button class="btn btn-secondary" onclick="stopPolling()">
            <span>‚èπ</span> Stop
        </button>
    </div>

    <div id="json-modal">
        <div class="modal-content">
            <h3 style="margin-bottom: 16px;">Paste Telemetry JSON</h3>
            <textarea id="json-input" placeholder='{"job": "build", "version": "0.10.2", ...}'></textarea>
            <div style="display: flex; gap: 12px;">
                <button class="btn btn-primary" onclick="parseJson()">Parse & Display</button>
                <button class="btn btn-secondary" onclick="hideJsonModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="dashboard">
        <!-- Overall Progress -->
        <div class="progress-container" id="overall-progress">
            <div class="progress-header">
                <span id="progress-label">Build Progress</span>
                <span id="progress-percent">0%</span>
            </div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill animated" id="progress-bar" style="width: 0%"></div>
            </div>
            <div class="progress-steps">
                <span id="progress-step-current">Starting...</span>
                <span id="progress-step-eta">Calculating...</span>
            </div>
        </div>

        <div class="grid">
            <!-- Job Overview -->
            <div class="card">
                <div class="card-header">
                    <div class="card-icon">üì¶</div>
                    <div class="card-title">Job Overview</div>
                </div>
                <div id="job-overview"></div>
            </div>

            <!-- Live Runner Metrics -->
            <div class="card grid-full">
                <div class="card-header">
                    <div class="card-icon">üìä</div>
                    <div class="card-title">Runner Metrics (Live)</div>
                    <span id="metrics-timestamp" style="font-size: 11px; color: var(--text-secondary);"></span>
                </div>
                <div id="live-metrics" class="metrics-grid">
                    <div class="metric-no-data">Warte auf Build-Start f√ºr Live-Metriken...</div>
                </div>
            </div>

            <!-- Current Activity -->
            <div class="card">
                <div class="card-header">
                    <div class="card-icon">üéØ</div>
                    <div class="card-title">Current Activity</div>
                </div>
                <div id="current-activity" style="padding: 8px 0;">
                    <div class="phase active" style="margin-bottom: 12px;">
                        <div class="phase-icon" id="activity-icon">‚è≥</div>
                        <div class="phase-info">
                            <div class="phase-name" id="activity-name">Waiting...</div>
                            <div class="phase-desc" id="activity-desc">-</div>
                        </div>
                        <div class="phase-status running" id="activity-timer">0:00</div>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); padding: 8px 16px; background: var(--bg-secondary); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Packer Provisioner:</span>
                            <span id="packer-step" style="color: var(--accent);">-</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>Phase:</span>
                            <span id="packer-phase" style="color: var(--warning);">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Logs -->
            <div class="card grid-full">
                <div class="card-header">
                    <div class="card-icon">üìú</div>
                    <div class="card-title">Live Logs</div>
                    <div class="log-count" id="log-count">0 lines</div>
                </div>
                <div id="live-logs" class="live-logs">
                    <div class="log-placeholder">Warte auf Logs...</div>
                </div>
            </div>

            <!-- Packer Internal Steps (VM Provisioning) -->
            <div class="card">
                <div class="card-header">
                    <div class="card-icon">üîß</div>
                    <div class="card-title">Packer Build Steps</div>
                    <span id="packer-steps-count" style="font-size: 11px; color: var(--text-secondary);">Live</span>
                </div>
                <div id="packer-steps-list" class="steps-list">
                    <div class="metric-no-data">Warte auf Packer Build...</div>
                </div>
            </div>

            <!-- GitHub Actions Steps -->
            <div class="card">
                <div class="card-header">
                    <div class="card-icon">üìã</div>
                    <div class="card-title">GitHub Actions Steps</div>
                </div>
                <div id="steps-list" class="steps-list"></div>
            </div>

            <!-- Duration Chart -->
            <div class="card grid-full">
                <div class="card-header">
                    <div class="card-icon">‚è±Ô∏è</div>
                    <div class="card-title">Step Durations</div>
                </div>
                <div class="chart-container" style="height: 400px;">
                    <canvas id="duration-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let pollingInterval = null;
        let durationChart, ioChart;

        function showJsonModal() { document.getElementById('json-modal').classList.add('active'); }
        function hideJsonModal() { document.getElementById('json-modal').classList.remove('active'); }

        function parseJson() {
            try {
                const data = JSON.parse(document.getElementById('json-input').value);
                renderDashboard(data);
                hideJsonModal();
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        function updateLiveBadge(status) {
            const badge = document.getElementById('live-badge');
            badge.className = 'live-badge';
            if (status === 'live') {
                badge.textContent = 'LIVE';
            } else if (status === 'stopped') {
                badge.classList.add('stopped');
                badge.textContent = 'STOPPED';
            } else {
                badge.classList.add('stopped');
                badge.textContent = status.toUpperCase();
            }
        }

        const REPO = 'obtFusi/network-agent';
        const LOCAL_STATUS_URL = '/network-agent/infrastructure/build-status.json';
        let currentRunId = null;
        let useLocalFile = true; // Try local file first

        // Live timer for current step
        let stepTimerInterval = null;
        function startStepTimer() {
            if (stepTimerInterval) clearInterval(stepTimerInterval);
            stepTimerInterval = setInterval(() => {
                if (window.currentStepStart) {
                    const elapsed = Math.floor((Date.now() - window.currentStepStart) / 1000);
                    const timerEl = document.getElementById('step-timer');
                    if (timerEl) timerEl.textContent = formatDuration(elapsed);
                }
            }, 1000);
        }

        function stopStepTimer() {
            if (stepTimerInterval) {
                clearInterval(stepTimerInterval);
                stepTimerInterval = null;
            }
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function saveTokenAndReload() {
            const token = document.getElementById('gh-token').value;
            if (token) {
                localStorage.setItem('gh-token', token);
                toggleSettings();
                manualRefresh();
            }
        }

        async function manualRefresh() {
            stopPolling();
            currentRunId = null;
            const runId = await fetchLatestRun();
            if (runId) {
                startPolling();
            }
        }

        async function ghFetch(url) {
            const resp = await fetch(url, { headers: getAuthHeaders() });
            // Check rate limit in headers
            const remaining = resp.headers.get('X-RateLimit-Remaining');
            if (remaining) {
                console.log(`API Rate: ${remaining} requests remaining`);
            }
            return resp;
        }

        // Fetch from local JSON file (updated by CLI script)
        async function fetchLocalStatus() {
            try {
                const resp = await fetch(LOCAL_STATUS_URL + '?t=' + Date.now());
                if (!resp.ok) return null;
                return await resp.json();
            } catch (e) {
                console.log('Local status file not available');
                return null;
            }
        }

        // Auto-fetch latest run on page load
        async function fetchLatestRun() {
            try {
                updateLiveBadge('LOADING');
                document.getElementById('run-info').textContent = 'Lade Build-Status...';

                // Try local file first (no rate limits!)
                const localData = await fetchLocalStatus();
                if (localData && !localData.error) {
                    currentRunId = localData.run_id;
                    const runType = localData.status === 'in_progress' ? 'üî¥ LIVE' : 'üìã';
                    document.getElementById('run-info').innerHTML = `${runType} Run: <a href="${localData.url}" target="_blank" style="color: var(--accent);">#${currentRunId}</a>`;
                    updateLiveBadge('live');
                    return localData;
                }

                // Fallback to GitHub API
                document.getElementById('run-info').textContent = 'Lokale Daten nicht gefunden, versuche GitHub API...';
                const runsUrl = `https://api.github.com/repos/${REPO}/actions/runs?per_page=5`;
                const resp = await fetch(runsUrl);
                if (!resp.ok) {
                    updateLiveBadge('ERROR');
                    document.getElementById('run-info').innerHTML = `
                        <span style="color: var(--warning);">Starte das Update-Script:</span><br>
                        <code style="background: var(--bg-secondary); padding: 4px 8px; border-radius: 4px;">./infrastructure/scripts/update-build-status.sh</code>
                    `;
                    return null;
                }
                const data = await resp.json();
                const latest = data.workflow_runs.find(r => r.status === 'in_progress') || data.workflow_runs[0];
                if (latest) {
                    currentRunId = latest.id;
                    return currentRunId;
                }
                return null;
            } catch (e) {
                console.error('Failed to fetch:', e);
                updateLiveBadge('ERROR');
                return null;
            }
        }

        async function fetchRunData() {
            try {
                // Try local file first (updated by CLI script)
                const localData = await fetchLocalStatus();
                if (localData && !localData.error) {
                    updateLiveBadge('live');
                    // Calculate duration for steps
                    if (localData.steps) {
                        const now = Date.now();
                        localData.steps = localData.steps.map(s => {
                            let duration_s = 0;
                            if (s.started_at && s.completed_at) {
                                // Completed step: use actual duration
                                duration_s = (new Date(s.completed_at) - new Date(s.started_at)) / 1000;
                            } else if (s.started_at && s.status === 'in_progress') {
                                // Running step: calculate elapsed time
                                duration_s = (now - new Date(s.started_at)) / 1000;
                            }
                            return { ...s, duration_s: Math.max(0, duration_s) };
                        });
                    }
                    return localData;
                }

                // No local data available
                updateLiveBadge('NO DATA');
                return null;
            } catch (e) {
                console.error('Fetch error:', e);
                updateLiveBadge('ERROR');
                return null;
            }
        }

        function parseTelemetryFromLogs(logs) {
            const steps = [];
            const lines = logs.split('\n');
            let currentStep = null;

            for (const line of lines) {
                // Match telemetry END markers
                const endMatch = line.match(/\[([^\]]+)\] END:/);
                if (endMatch) {
                    if (currentStep) {
                        steps.push(currentStep);
                    }
                    currentStep = { name: endMatch[1] };
                }
                if (currentStep) {
                    const durMatch = line.match(/Duration:\s*([\d.]+)s/);
                    if (durMatch) currentStep.duration_s = parseFloat(durMatch[1]);

                    const cpuMatch = line.match(/CPU:\s*~?([\d.]+)%/);
                    if (cpuMatch) currentStep.cpu_percent = parseFloat(cpuMatch[1]);

                    const memMatch = line.match(/Memory:\s*(\d+)MB/);
                    if (memMatch) currentStep.memory_mb = parseInt(memMatch[1]);

                    const diskReadMatch = line.match(/Disk Read:\s*(\d+)MB/);
                    if (diskReadMatch) currentStep.disk_read_mb = parseInt(diskReadMatch[1]);

                    const diskWriteMatch = line.match(/Disk Write:\s*(\d+)MB/);
                    if (diskWriteMatch) currentStep.disk_write_mb = parseInt(diskWriteMatch[1]);

                    const ioMatch = line.match(/util=(\d+)%.*await=(\d+)ms.*queue=([\d.]+)/);
                    if (ioMatch) {
                        currentStep.disk_util_percent = parseInt(ioMatch[1]);
                        currentStep.await_ms = parseInt(ioMatch[2]);
                        currentStep.queue_depth = parseFloat(ioMatch[3]);
                    }
                }
            }
            if (currentStep && currentStep.name) {
                steps.push(currentStep);
            }
            return steps;
        }

        function startPolling() {
            const runId = currentRunId || document.getElementById('run-id').value;
            if (!runId) {
                alert('No run to monitor');
                return;
            }
            currentRunId = runId;
            updateLiveBadge('live');

            // Initial fetch
            pollOnce();

            // Then poll every 5 seconds
            // Poll every 30s to avoid GitHub API rate limits (60/hour unauthenticated)
            pollingInterval = setInterval(pollOnce, 10000);  // 10s refresh for live updates
        }

        async function pollOnce() {
            const data = await fetchRunData();
            if (data) {
                renderDashboard(data);

                // Stop polling if completed
                if (data.status === 'completed') {
                    stopPolling();
                    updateLiveBadge('DONE');
                }
            }
        }

        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            stopStepTimer();
            updateLiveBadge('stopped');
        }

        function formatDuration(s) {
            if (s < 60) return s.toFixed(1) + 's';
            if (s < 3600) return Math.floor(s/60) + 'm ' + Math.floor(s%60) + 's';
            return Math.floor(s/3600) + 'h ' + Math.floor((s%3600)/60) + 'm';
        }

        function formatMB(mb) {
            return mb >= 1024 ? (mb/1024).toFixed(1) + ' GB' : mb + ' MB';
        }

        function getValueClass(val, warn, danger) {
            if (val >= danger) return 'danger';
            if (val >= warn) return 'warning';
            return '';
        }

        function renderDashboard(data) {
            document.getElementById('dashboard').classList.add('active');

            // Calculate total elapsed time
            const startTime = data.started_at ? new Date(data.started_at) : null;
            const elapsed = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;

            // Find current running step
            const runningStep = data.steps?.find(s => s.status === 'in_progress');
            const completedSteps = data.steps?.filter(s => s.status === 'completed').length || 0;
            const totalSteps = data.steps?.length || 0;

            // Job Overview
            document.getElementById('job-overview').innerHTML = `
                <div class="metric-row"><span class="metric-label">Job</span><span class="metric-value">${data.job}</span></div>
                <div class="metric-row"><span class="metric-label">Branch</span><span class="metric-value highlight">${data.version}</span></div>
                <div class="metric-row"><span class="metric-label">Status</span><span class="metric-value ${data.status}">${data.status}</span></div>
                <div class="metric-row"><span class="metric-label">Elapsed</span><span class="metric-value">${formatDuration(elapsed)}</span></div>
                <div class="metric-row"><span class="metric-label">Progress</span><span class="metric-value">${completedSteps}/${totalSteps} steps</span></div>
            `;

            // Update overall progress bar
            const progressPercent = totalSteps > 0 ? Math.round((completedSteps / totalSteps) * 100) : 0;
            document.getElementById('progress-bar').style.width = progressPercent + '%';
            document.getElementById('progress-percent').textContent = progressPercent + '%';

            if (runningStep) {
                document.getElementById('progress-step-current').textContent = `Step ${completedSteps + 1}/${totalSteps}: ${runningStep.name}`;
                // Estimate based on average step time
                const avgStepTime = elapsed > 0 && completedSteps > 0 ? elapsed / completedSteps : 120;
                const remainingSteps = totalSteps - completedSteps;
                const eta = Math.round(avgStepTime * remainingSteps);
                document.getElementById('progress-step-eta').textContent = `~${formatDuration(eta)} remaining`;
                document.getElementById('progress-bar').classList.add('animated');
            } else {
                document.getElementById('progress-step-current').textContent = data.status === 'completed' ? 'Build complete' : 'Waiting...';
                document.getElementById('progress-step-eta').textContent = '';
                document.getElementById('progress-bar').classList.remove('animated');
            }

            // Store step start time for live timer
            if (runningStep) {
                window.currentStepStart = runningStep.started_at ? new Date(runningStep.started_at) : null;
                startStepTimer();
            } else {
                window.currentStepStart = null;
            }

            if (data.steps?.length) {
                renderStepsList(data.steps);
                // Render duration chart with step data
                renderDurationChart(data.steps);
            }

            // Render internal Packer build steps (VM provisioning)
            if (data.packer_steps?.length) {
                renderPackerSteps(data.packer_steps);
            }

            // Render live logs if available
            if (data.logs?.length) {
                renderLiveLogs(data.logs);
            }

            // Render live metrics from runner
            renderMetrics(data.metrics, data.status);

            // Update current activity display
            updateCurrentActivity(runningStep, data.status, completedSteps, totalSteps);
        }

        function renderMetrics(metrics, buildStatus) {
            const container = document.getElementById('live-metrics');
            const timestampEl = document.getElementById('metrics-timestamp');

            if (!metrics || Object.keys(metrics).length === 0) {
                if (buildStatus === 'in_progress') {
                    container.innerHTML = '<div class="metric-no-data">‚è≥ Verbinde mit Runner...</div>';
                } else {
                    container.innerHTML = '<div class="metric-no-data">Metrics nur w√§hrend Build verf√ºgbar</div>';
                }
                timestampEl.textContent = '';
                return;
            }

            timestampEl.textContent = 'Updated: ' + new Date().toLocaleTimeString();

            // CPU Card
            const cpuUsed = (metrics.cpu_user || 0) + (metrics.cpu_sys || 0);
            const cpuClass = cpuUsed > 90 ? 'danger' : cpuUsed > 70 ? 'warning' : 'cpu';

            // Memory Card
            const memPercent = metrics.mem_total ? Math.round((metrics.mem_used / metrics.mem_total) * 100) : 0;
            const memClass = memPercent > 90 ? 'danger' : memPercent > 70 ? 'warning' : 'mem';

            // Disk I/O - show rates
            const diskReads = metrics.disk_reads || 0;
            const diskWrites = metrics.disk_writes || 0;

            // Network
            const netRx = metrics.net_rx || 0;
            const netTx = metrics.net_tx || 0;

            container.innerHTML = `
                <!-- CPU -->
                <div class="metric-card">
                    <div class="metric-card-header">üî• CPU</div>
                    <div class="metric-card-value ${cpuClass}">${cpuUsed.toFixed(0)}%</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill ${cpuClass}" style="width: ${Math.min(cpuUsed, 100)}%"></div>
                    </div>
                    <div class="metric-details">
                        <div class="metric-detail"><span>User</span><span class="metric-detail-value">${metrics.cpu_user || 0}%</span></div>
                        <div class="metric-detail"><span>System</span><span class="metric-detail-value">${metrics.cpu_sys || 0}%</span></div>
                        <div class="metric-detail"><span>I/O Wait</span><span class="metric-detail-value">${metrics.cpu_iowait || 0}%</span></div>
                        <div class="metric-detail"><span>Load</span><span class="metric-detail-value">${metrics.load || '-'}</span></div>
                    </div>
                </div>

                <!-- Memory -->
                <div class="metric-card">
                    <div class="metric-card-header">üíæ Memory</div>
                    <div class="metric-card-value ${memClass}">${memPercent}%</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill ${memClass}" style="width: ${Math.min(memPercent, 100)}%"></div>
                    </div>
                    <div class="metric-details">
                        <div class="metric-detail"><span>Used</span><span class="metric-detail-value">${formatBytes(metrics.mem_used * 1024 * 1024)}</span></div>
                        <div class="metric-detail"><span>Total</span><span class="metric-detail-value">${formatBytes(metrics.mem_total * 1024 * 1024)}</span></div>
                        <div class="metric-detail"><span>Free</span><span class="metric-detail-value">${formatBytes(metrics.mem_free * 1024 * 1024)}</span></div>
                        <div class="metric-detail"><span>Avail</span><span class="metric-detail-value">${formatBytes((metrics.mem_total - metrics.mem_used) * 1024 * 1024)}</span></div>
                    </div>
                </div>

                <!-- Disk I/O -->
                <div class="metric-card">
                    <div class="metric-card-header">üíø Disk I/O</div>
                    <div class="metric-card-value disk">${metrics.iops || 0} <span style="font-size: 14px;">IOPS</span></div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill disk" style="width: ${Math.min((metrics.iops || 0) / 1000 * 100, 100)}%"></div>
                    </div>
                    <div class="metric-details">
                        <div class="metric-detail"><span>Read</span><span class="metric-detail-value">${metrics.disk_read_mb || 0} MB/s</span></div>
                        <div class="metric-detail"><span>Write</span><span class="metric-detail-value">${metrics.disk_write_mb || 0} MB/s</span></div>
                        <div class="metric-detail"><span>I/O Wait</span><span class="metric-detail-value">${metrics.cpu_iowait || 0}%</span></div>
                        <div class="metric-detail"><span>Load</span><span class="metric-detail-value">${metrics.load || '-'}</span></div>
                    </div>
                </div>

                <!-- Network -->
                <div class="metric-card">
                    <div class="metric-card-header">üåê Network</div>
                    <div class="metric-card-value net">${(metrics.net_rx_mb || 0) + (metrics.net_tx_mb || 0)} <span style="font-size: 14px;">MB/s</span></div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill net" style="width: ${Math.min(((metrics.net_rx_mb || 0) + (metrics.net_tx_mb || 0)) / 100 * 100, 100)}%"></div>
                    </div>
                    <div class="metric-details">
                        <div class="metric-detail"><span>‚Üì RX</span><span class="metric-detail-value">${metrics.net_rx_mb || 0} MB/s</span></div>
                        <div class="metric-detail"><span>‚Üë TX</span><span class="metric-detail-value">${metrics.net_tx_mb || 0} MB/s</span></div>
                        ${metrics.qemu_cpu ? `<div class="metric-detail"><span>QEMU CPU</span><span class="metric-detail-value">${metrics.qemu_cpu}%</span></div>` : ''}
                        ${metrics.qemu_mem ? `<div class="metric-detail"><span>QEMU Mem</span><span class="metric-detail-value">${metrics.qemu_mem}%</span></div>` : ''}
                    </div>
                </div>
            `;
        }

        function formatBytes(bytes) {
            if (!bytes || bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function renderLiveLogs(logs) {
            const container = document.getElementById('live-logs');
            const countEl = document.getElementById('log-count');

            if (!logs || logs.length === 0) {
                container.innerHTML = '<div class="log-placeholder">Warte auf Logs...</div>';
                countEl.textContent = '0 lines';
                return;
            }

            countEl.textContent = `${logs.length} lines`;

            const html = logs.map(line => {
                let className = 'log-line';
                if (line.includes('packer') || line.includes('Packer')) className += ' packer';
                else if (line.includes('qemu') || line.includes('QEMU')) className += ' qemu';
                else if (line.includes('docker') || line.includes('Docker')) className += ' docker';
                else if (line.toLowerCase().includes('error') || line.toLowerCase().includes('failed')) className += ' error';
                return `<div class="${className}">${escapeHtml(line)}</div>`;
            }).join('');

            container.innerHTML = html;
            // Auto-scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateCurrentActivity(runningStep, buildStatus, completedSteps, totalSteps) {
            const nameEl = document.getElementById('activity-name');
            const descEl = document.getElementById('activity-desc');
            const iconEl = document.getElementById('activity-icon');
            const timerEl = document.getElementById('activity-timer');
            const packerStepEl = document.getElementById('packer-step');
            const packerPhaseEl = document.getElementById('packer-phase');

            if (buildStatus === 'completed') {
                nameEl.textContent = 'Build Complete';
                descEl.textContent = `${completedSteps}/${totalSteps} steps finished`;
                iconEl.textContent = '‚úÖ';
                timerEl.textContent = 'Done';
                packerStepEl.textContent = '-';
                packerPhaseEl.textContent = 'Finished';
                return;
            }

            if (!runningStep) {
                nameEl.textContent = 'Waiting...';
                descEl.textContent = 'Build not started';
                iconEl.textContent = '‚è≥';
                timerEl.textContent = '-';
                packerStepEl.textContent = '-';
                packerPhaseEl.textContent = '-';
                return;
            }

            // Determine icon and phase based on step name
            const stepName = runningStep.name || '';
            const stepLower = stepName.toLowerCase();
            let icon = 'üîÑ';
            let phase = 'Setup';

            if (stepLower.includes('cache') || stepLower.includes('ollama') || stepLower.includes('download')) {
                icon = 'üì•';
                phase = 'Cache/Download';
            } else if (stepLower.includes('packer') || stepLower.includes('init')) {
                icon = 'üîß';
                phase = 'Packer Init';
            } else if (stepLower.includes('build appliance')) {
                icon = 'üèóÔ∏è';
                phase = 'VM Build (Packer)';
            } else if (stepLower.includes('verify')) {
                icon = '‚úÖ';
                phase = 'Verification';
            } else if (stepLower.includes('split') || stepLower.includes('compress')) {
                icon = 'üì¶';
                phase = 'Packaging';
            } else if (stepLower.includes('upload') || stepLower.includes('minio')) {
                icon = '‚òÅÔ∏è';
                phase = 'Upload';
            } else if (stepLower.includes('docker')) {
                icon = 'üê≥';
                phase = 'Docker';
            } else if (stepLower.includes('cleanup')) {
                icon = 'üßπ';
                phase = 'Cleanup';
            }

            // Calculate elapsed time for current step
            let elapsed = '-';
            if (runningStep.started_at) {
                const start = new Date(runningStep.started_at);
                const now = new Date();
                const seconds = Math.floor((now - start) / 1000);
                elapsed = formatDuration(seconds);
            }

            nameEl.textContent = stepName;
            descEl.textContent = `Step ${completedSteps + 1} of ${totalSteps}`;
            iconEl.textContent = icon;
            timerEl.textContent = elapsed;
            packerPhaseEl.textContent = phase;

            // Show current Packer step if in Build appliance phase
            if (stepName.includes('Build appliance') && window.currentPackerStep) {
                packerStepEl.textContent = window.currentPackerStep;
            } else {
                packerStepEl.textContent = stepName.includes('Build appliance') ? 'Running VM provisioners...' : '-';
            }
        }

        function renderStepsList(steps) {
            const html = steps.map(s => {
                let icon, iconClass;
                if (s.status === 'in_progress') {
                    icon = '‚óè';
                    iconClass = 'running';
                } else if (s.status === 'completed') {
                    if (s.conclusion === 'success') {
                        icon = '‚úì';
                        iconClass = 'completed';
                    } else if (s.conclusion === 'skipped') {
                        icon = '‚äò';
                        iconClass = 'skipped';
                    } else {
                        icon = '‚úó';
                        iconClass = 'failed';
                    }
                } else {
                    icon = '‚óã';
                    iconClass = 'pending';
                }
                return `
                    <div class="step-item ${s.status === 'in_progress' ? 'active' : ''}">
                        <div class="step-icon ${iconClass}">${icon}</div>
                        <span class="step-name">${s.name.replace(/Step\d+_/, '')}</span>
                        <span class="step-duration">${formatDuration(s.duration_s || 0)}</span>
                    </div>
                `;
            }).join('');
            document.getElementById('steps-list').innerHTML = html;
        }

        function renderPackerSteps(packerSteps) {
            const container = document.getElementById('packer-steps-list');
            const countEl = document.getElementById('packer-steps-count');

            if (!packerSteps || packerSteps.length === 0) {
                container.innerHTML = '<div class="metric-no-data">Warte auf Packer Build...</div>';
                countEl.textContent = '';
                window.currentPackerStep = null;
                return;
            }

            // Count completed and in-progress
            const completed = packerSteps.filter(s => s.status === 'completed').length;
            const inProgress = packerSteps.find(s => s.status === 'in_progress');
            countEl.textContent = `${completed}/${packerSteps.length} done${inProgress ? ' ‚Ä¢ üîÑ Live' : ''}`;

            // Store current Packer step for activity display
            window.currentPackerStep = inProgress ?
                inProgress.name.replace(/^Step\d+[a-z]?_/, '').replace(/_/g, ' ') :
                null;

            const html = packerSteps.map(s => {
                let icon, iconClass;
                if (s.status === 'in_progress') {
                    icon = '‚óè';
                    iconClass = 'running';
                } else if (s.status === 'completed') {
                    icon = '‚úì';
                    iconClass = 'completed';
                } else {
                    icon = '‚óã';
                    iconClass = 'pending';
                }

                // Calculate duration
                let duration = 0;
                if (s.started_at && s.completed_at) {
                    duration = (new Date(s.completed_at) - new Date(s.started_at)) / 1000;
                } else if (s.started_at && s.status === 'in_progress') {
                    duration = (Date.now() - new Date(s.started_at)) / 1000;
                }

                // Format step name (remove Step prefix, replace underscores)
                const displayName = s.name
                    .replace(/^Step\d+[a-z]?_/, '')
                    .replace(/_/g, ' ');

                return `
                    <div class="step-item ${s.status === 'in_progress' ? 'active' : ''}">
                        <div class="step-icon ${iconClass}">${icon}</div>
                        <span class="step-name">${displayName}</span>
                        <span class="step-duration">${formatDuration(duration)}</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function renderDurationChart(steps) {
            // Filter steps with actual duration > 0
            const stepsWithDuration = steps.filter(s => s.duration_s > 0);
            if (stepsWithDuration.length === 0) return;

            const labels = stepsWithDuration.map(s => {
                // Shorten long names
                let name = s.name.replace(/^(Run |Pre |Post )/, '').replace('actions/', '');
                return name.length > 25 ? name.substring(0, 22) + '...' : name;
            });

            // Duration Chart
            const ctxD = document.getElementById('duration-chart')?.getContext('2d');
            if (!ctxD) return;

            if (durationChart) durationChart.destroy();
            durationChart = new Chart(ctxD, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Duration (s)',
                        data: stepsWithDuration.map(s => s.duration_s),
                        backgroundColor: stepsWithDuration.map(s =>
                            s.status === 'in_progress' ? '#ffaa00' :
                            s.duration_s > 300 ? '#ff4466' :
                            s.duration_s > 60 ? '#ffaa00' : '#00d4ff'),
                        borderRadius: 6
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatDuration(ctx.raw)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#3a3a5a' },
                            ticks: {
                                color: '#a0a0b0',
                                callback: (v) => formatDuration(v)
                            }
                        },
                        y: { grid: { display: false }, ticks: { color: '#a0a0b0', font: { size: 11 } } }
                    }
                }
            });
        }

        // Auto-start on page load
        async function autoStart() {
            const runId = await fetchLatestRun();
            if (runId) {
                startPolling();
            } else {
                updateLiveBadge('NO RUNS');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', autoStart);
    </script>
</body>
</html>
